name: spring-boot Github Actions

on:
  push:
    branches: [ "master" ]
env:
  PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
  ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
  ECS_TASK_DEFINITION_FAMILY: ${{ secrets.ECS_TASK_DEFINITION_FAMILY }}
  ECS_CONTAINER_NAME: ${{ secrets.ECS_CONTAINER_NAME }}
  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
  ARGOCD_USERNAME: ${{ secrets.ARGOCD_USERNAME }}
  ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}
  GIT_USERNAME: ${{ secrets.GIT_USERNAME }}
  GIT_EMAIL: ${{ secrets.GIT_EMAIL }}

jobs:
  Building-and-Testing:
    runs-on: ubuntu-latest
    #Todo Not strictly needed for Docker Hub, but good to include if you might switch.
    #Todo Required to push to GitHub Container Registry (ghcr.io)
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'maven' # Strongly recommended for faster builds!
          cache-dependency-path: 'pom.xml' # Or '**/pom.xml' for multi-module projects

      - name: Setup Maven
        uses: stCarolas/setup-maven@v4.4
        with:
          maven-version: 3.8.2

      - name: Build with Maven (No Tests)
        run: mvn clean install -DskipTests -B # -B for batch mode (non-interactive)

      - name: Run Unit Tests
        run: mvn test -B # -B for batch mode (non-interactive)

      # Optional: Add integration tests as a separate step
      - name: Run Integration Tests
        run: mvn verify -Pintegration-tests # Assuming you have a profile for ITs

        # Optional: Package and create artifact (if not already done by 'install')
        # This is especially useful if 'install' wasn't used, or you want a fresh package post-tests
      - name: Package Application
        run: mvn package -DskipTests -B # Skip tests again if they already ran
        #   This step is usually redundant if 'mvn clean install' was used as it also packages

        # Optional: Upload build artifacts (e.g., JAR/WAR file)
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: your-application-artifact
          path: target/*.jar # Adjust path as needed (e.g., target/*.war)
          # retain-days: 5 # Good practice to limit retention for production artifacts
      - name: Simulate Build and Create Artifacts
        # In a real application, this would be your actual build command (e.g., mvn package, npm run build)
        # which outputs files to a 'target' or 'dist' directory.
        # Here, we create a 'staging' directory and a dummy file to represent your build output.
        run: |
          echo "Simulating application build..."
          mkdir -p staging/app
          echo "This is your compiled application or build artifact." > staging/app/my-app.txt
          echo "Build version: ${{ github.run_number }}" > staging/app/version.txt
          echo "Build output created in 'staging' directory."    

      - name: Upload Build Artifact
        # This step takes the 'staging' directory and uploads it as an artifact
        # named 'application-package'. This artifact can then be downloaded by other jobs.
        uses: actions/upload-artifact@v4
        with:
          name: application-package # A descriptive name for your artifact
          path: staging/             # The path to the directory or file(s) to upload
          # retention-days: 5        # Optional: How long to retain the artifact (e.g., 5 days).
          # Good practice for managing storage in production.
      - name: Log in to Docker Hub
        uses: docker/login-action@v3 # Using the official Docker login action
        with:
          username: ${{ secrets.DOCKER_USERNAME }} # Accessing the username from GitHub Secrets
          password: ${{ secrets.DOCKER_PASSWORD }} # Accessing the password/token from GitHub Secrets

      - name: Build docker image
        run: docker build -t spring-application-k8s .
      - name: Tag docker image
        run: docker tag spring-application-k8s srinu641/spring-application-k8s:v3.02
      - name: Push docker image
        run: docker push srinu641/spring-application-k8s:v3.02
      - name: Getting Docker Images
        run: |
          docker images
          docker ps -a

      - name: Scan Docker Image with Trivy
        run: docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image ${{ secrets.DOCKERHUB_USERNAME }}/my-app:${{ github.sha }}

      # SonarQube Analysis
#      - name: SonarCloud Scan
#        uses: SonarSource/sonarcloud-github-action@master
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
#          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd

      - name: Login to ArgoCD
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
              --username ${{ secrets.ARGOCD_USERNAME }} \
              --password ${{ secrets.ARGOCD_PASSWORD }} \
              --insecure

      - name: Run Trivy vulnerability scan
        uses: aquasecurity/trivy-action@0.20.0 # Use a specific version for stability
        with:
          image-ref: 'spring-application-k8s' # Scan the locally built image
          format: 'sarif' # Recommended for GitHub Code Scanning integration
          output: 'trivy-results.sarif'
          exit-code: '1' # Fail the action if vulnerabilities are found
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH' # Only report critical and high severity issues

#      - name:
#        uses: aws-action/configure-aws-credentials@v1
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRETS_KEY }}
#          aws-region: us-east-1
#
#      - name: Login to Amazon ECR
#        id: login-ecr
#        uses: aws-actions/amazon-ecr-login@v1
#
#      - name: Build ,Tag, and push too ECR
#        env:
#          ECP_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#          ECR_REGISTRY: repo_ecr_name
#          IMAGE_TAG: ${{ github.sha }}
#        run: |
#          docker build -t $ECR_REGISTRY/$ECR_REGISTRY:v1.0
#          docker push -a $ECR_REGISTRY/$ECR_REGISTRY:v1.0
#
#      - name: update kube config
#        run: aws eks update_kubeconfig --name cluster_name --region us-east-1
#
#      - name: Deploy k8s
#        run: |
#          k apply -f file_name -n namespce_name

      # Set up AWS Credentials
#      - name: Configure AWS Credentials
#        uses: aws-actions/configure-aws-credentials@v2
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ secrets.AWS_REGION }}
#
#      # Log in to Amazon ECR
#      - name: Log in to Amazon ECR
#        run: |
#          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY_URI }}
#
#      # Push image to Amazon ECR
#      - name: Push image to Amazon ECR
#        run: |
#          docker push ${{ secrets.ECR_REPOSITORY_URI}}/actions-cicd:latest
#        env:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ secrets.AWS_REGION }}
#
#      # Update Kubeconfig
#      - name: Update kubeconfig
#        run: aws eks --region ${{ secrets.AWS_REGION }} update-kubeconfig --name actions-eks-cluster
#
#      # Install kubectl
#      - name: Install kubectl
#        run: |
#          curl -o kubectl https://amazon-eks.s3.us-west-2.amazonaws.com/1.21.2/2021-07-05/bin/linux/amd64/kubectl
#          chmod +x ./kubectl
#          sudo mv ./kubectl /usr/local/bin/kubectl
#
#      # Deploy to Amazon EKS
#      - name: Deploy to EKS
#        run: |
#          kubectl apply -f k8s-manifests/deployment.yaml
#          kubectl apply -f k8s-manifests/service.yaml
